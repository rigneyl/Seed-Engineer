(function () {
  const tones = [
    "caustic",
    "melancholic",
    "clinical",
    "absurd",
    "apathetic",
    "volatile",
    "funereal",
  ];

  const seedEntries = [
    {
      term: "Anthropoid Fatigue",
      definition:
        "A weariness not from effort, but from prolonged exposure to human behaviour.",
      tone: "clinical",
      usage:
        "By late afternoon he felt the anthropoid fatigue settle into his bones.",
    },
    {
      term: "Civility Theater",
      definition:
        "The ritual of polite gestures masking boredom, contempt, or mutual indifference.",
      tone: "caustic",
      usage:
        "The weekly stand-up was little more than civility theater in fluorescent lighting.",
    },
    {
      term: "Moral Exhaustion",
      definition:
        "The tiredness that comes from repeatedly watching people choose what benefits them over what is right.",
      tone: "melancholic",
      usage:
        "Her moral exhaustion showed whenever the news accidentally played in the background.",
    },
    {
      term: "Human Static",
      definition:
        "Background noise generated by opinions, updates, and performative outrage.",
      tone: "absurd",
      usage:
        "He muted the group chat and enjoyed ten full minutes without human static.",
    },
    {
      term: "Civilization Hangover",
      definition:
        "The psychic residue left after prolonged exposure to crowds, advertising, and small talk.",
      tone: "funereal",
      usage:
        "The train ride home was just him and his civilization hangover staring out the window.",
    },
  ];

  let entries = [...seedEntries];

  const bodyEl = document.body;
  const tbodyEl = document.getElementById("lexicon-body");
  const searchInput = document.getElementById("search-input");
  const toneFilter = document.getElementById("tone-filter");
  const addRowBtn = document.getElementById("add-row");
  const exportMdBtn = document.getElementById("export-md");
  const exportJsonBtn = document.getElementById("export-json");
  const importJsonInput = document.getElementById("import-json");
  const toneStatsEl = document.getElementById("tone-stats");
  const modeEditBtn = document.getElementById("mode-edit");
  const modePreviewBtn = document.getElementById("mode-preview");
  const editorViewEl = document.getElementById("editor-view");
  const previewViewEl = document.getElementById("preview-view");
  const previewContentEl = document.getElementById("preview-content");

  function render() {
    renderTable();
    renderToneStats();
    if (previewViewEl.classList.contains("active")) {
      renderPreview();
    }
  }

  function matchesFilters(entry) {
    const q = (searchInput.value || "").toLowerCase();
    const toneValue = toneFilter.value;

    const matchesTone = toneValue === "all" || entry.tone === toneValue;

    const haystack =
      (entry.term + " " + entry.definition + " " + entry.usage).toLowerCase();
    const matchesSearch = !q || haystack.includes(q);

    return matchesTone && matchesSearch;
  }

  function renderTable() {
    tbodyEl.innerHTML = "";
    entries.forEach((entry, index) => {
      if (!matchesFilters(entry)) return;

      const tr = document.createElement("tr");
      tr.dataset.index = String(index);
      tr.dataset.tone = entry.tone || "";

      const tdTerm = document.createElement("td");
      const tdDef = document.createElement("td");
      const tdTone = document.createElement("td");
      const tdUsage = document.createElement("td");

      const termDiv = document.createElement("div");
      termDiv.className = "cell-editable";
      termDiv.contentEditable = "true";
      termDiv.textContent = entry.term || "";
      termDiv.dataset.field = "term";

      const defDiv = document.createElement("div");
      defDiv.className = "cell-editable";
      defDiv.contentEditable = "true";
      defDiv.textContent = entry.definition || "";
      defDiv.dataset.field = "definition";

      const usageDiv = document.createElement("div");
      usageDiv.className = "cell-editable";
      usageDiv.contentEditable = "true";
      usageDiv.textContent = entry.usage || "";
      usageDiv.dataset.field = "usage";

      const toneSelect = document.createElement("select");
      toneSelect.className = "tone-select";
      tones.forEach((tone) => {
        const opt = document.createElement("option");
        opt.value = tone;
        opt.textContent = tone.charAt(0).toUpperCase() + tone.slice(1);
        toneSelect.appendChild(opt);
      });
      toneSelect.value = entry.tone || "caustic";

      tdTerm.appendChild(termDiv);
      tdDef.appendChild(defDiv);
      tdTone.appendChild(toneSelect);
      tdUsage.appendChild(usageDiv);

      tr.appendChild(tdTerm);
      tr.appendChild(tdDef);
      tr.appendChild(tdTone);
      tr.appendChild(tdUsage);

      tbodyEl.appendChild(tr);
    });
  }

  function renderToneStats() {
    const counts = {};
    tones.forEach((t) => (counts[t] = 0));
    entries.forEach((e) => {
      if (tones.includes(e.tone)) {
        counts[e.tone]++;
      }
    });

    const total = entries.length || 1;
    toneStatsEl.innerHTML = "";
    tones.forEach((tone) => {
      const row = document.createElement("div");
      row.className = "tone-row";

      const name = document.createElement("span");
      name.className = "tone-name";
      name.textContent = tone;

      const shell = document.createElement("div");
      shell.className = "tone-bar-shell";

      const bar = document.createElement("div");
      bar.className = "tone-bar";
      bar.style.width = ((counts[tone] / total) * 100).toFixed(0) + "%";

      shell.appendChild(bar);

      const count = document.createElement("span");
      count.className = "tone-count";
      count.textContent = String(counts[tone]);

      row.appendChild(name);
      row.appendChild(shell);
      row.appendChild(count);

      toneStatsEl.appendChild(row);
    });
  }

  function groupByFirstLetter(list) {
    const map = new Map();
    list.forEach((e) => {
      const letter = (e.term || "")
        .trim()
        .charAt(0)
        .toUpperCase();
      const key = letter && letter.match(/[A-Z]/) ? letter : "#";
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(e);
    });
    return Array.from(map.entries())
      .sort((a, b) => a[0].localeCompare(b[0]))
      .map(([key, arr]) => [key, arr.sort((x, y) => x.term.localeCompare(y.term))]);
  }

  function generateMarkdown() {
    const visibleEntries = entries.filter((e) => matchesFilters(e));
    const grouped = groupByFirstLetter(visibleEntries);

    let lines = ["# Lexicon", ""];
    grouped.forEach(([letter, group]) => {
      lines.push(`## ${letter}`);
      lines.push("");
      group.forEach((entry) => {
        if (!entry.term && !entry.definition && !entry.usage) return;
        lines.push(`### ${entry.term || "Untitled term"}`);
        if (entry.tone) {
          const toneLabel =
            entry.tone.charAt(0).toUpperCase() + entry.tone.slice(1);
          lines.push(`**Tone:** ${toneLabel}`);
        }
        if (entry.definition) {
          lines.push(`**Definition:** ${entry.definition}`);
        }
        if (entry.usage) {
          lines.push(`**Usage:** ${entry.usage}`);
        }
        lines.push("");
      });
    });

    if (lines.length === 2) {
      lines.push("_No entries to display. Add terms to your lexicon._");
    }

    return lines.join("\n");
  }

  function renderPreview() {
    previewContentEl.textContent = generateMarkdown();
  }

  function downloadFile(filename, mime, content) {
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function syncFromDom() {
    const rows = Array.from(tbodyEl.querySelectorAll("tr"));
    rows.forEach((tr) => {
      const index = parseInt(tr.dataset.index, 10);
      const term = tr.querySelector('[data-field="term"]')?.textContent || "";
      const definition =
        tr.querySelector('[data-field="definition"]')?.textContent || "";
      const usage =
        tr.querySelector('[data-field="usage"]')?.textContent || "";
      const tone = tr.querySelector("select")?.value || "caustic";

      if (!entries[index]) return;
      entries[index].term = term.trim();
      entries[index].definition = definition.trim();
      entries[index].usage = usage.trim();
      entries[index].tone = tone;
    });
  }

  function addEmptyRow() {
    entries.push({
      term: "",
      definition: "",
      tone: "caustic",
      usage: "",
    });
    render();
  }

  // Events
  addRowBtn.addEventListener("click", () => {
    addEmptyRow();
  });

  searchInput.addEventListener("input", () => {
    render();
  });

  toneFilter.addEventListener("change", () => {
    render();
  });

  tbodyEl.addEventListener("focusout", (e) => {
    if (e.target.classList.contains("cell-editable")) {
      syncFromDom();
      renderToneStats();
      if (previewViewEl.classList.contains("active")) {
        renderPreview();
      }
    }
  });

  tbodyEl.addEventListener("change", (e) => {
    if (e.target.classList.contains("tone-select")) {
      const tr = e.target.closest("tr");
      const index = parseInt(tr.dataset.index, 10);
      entries[index].tone = e.target.value;
      tr.dataset.tone = e.target.value;
      renderToneStats();
      if (previewViewEl.classList.contains("active")) {
        renderPreview();
      }
    }
  });

  tbodyEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      if (e.target.classList.contains("cell-editable")) {
        e.preventDefault();
        const rows = Array.from(tbodyEl.querySelectorAll("tr"));
        const lastRow = rows[rows.length - 1];
        if (lastRow && lastRow.contains(e.target)) {
          addEmptyRow();
          const newRows = Array.from(tbodyEl.querySelectorAll("tr"));
          const newest = newRows[newRows.length - 1];
          const firstCell = newest.querySelector('[data-field="term"]');
          if (firstCell) {
            firstCell.focus();
          }
        }
      }
    }
  });

  exportMdBtn.addEventListener("click", () => {
    syncFromDom();
    const md = generateMarkdown();
    downloadFile("lexicon.md", "text/markdown", md);
  });

  exportJsonBtn.addEventListener("click", () => {
    syncFromDom();
    const json = JSON.stringify({ entries }, null, 2);
    downloadFile("lexicon.json", "application/json", json);
  });

  importJsonInput.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (Array.isArray(data)) {
          entries = data;
        } else if (Array.isArray(data.entries)) {
          entries = data.entries;
        } else {
          alert("JSON does not look like a lexicon export.");
          return;
        }
        render();
      } catch (err) {
        console.error(err);
        alert("Could not parse JSON.");
      } finally {
        importJsonInput.value = "";
      }
    };
    reader.readAsText(file);
  });

  function setMode(mode) {
    if (mode === "preview") {
      modePreviewBtn.classList.add("btn-active");
      modeEditBtn.classList.remove("btn-active");
      editorViewEl.classList.add("inactive");
      previewViewEl.classList.add("active");
      renderPreview();
    } else {
      modeEditBtn.classList.add("btn-active");
      modePreviewBtn.classList.remove("btn-active");
      editorViewEl.classList.remove("inactive");
      previewViewEl.classList.remove("active");
    }
  }

  modeEditBtn.addEventListener("click", () => setMode("edit"));
  modePreviewBtn.addEventListener("click", () => setMode("preview"));

  // Initial render
  render();
})();
